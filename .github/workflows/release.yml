name: release

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      release_id: ${{ steps.release.outputs.id }}
    steps:
      - uses: actions/checkout@v4

      - id: release
        uses: googleapis/release-please-action@v4
        with:
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          target-branch: main

  build:
    needs: release-please
    if: needs.release-please.outputs.release_created == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            bundles: "msi"
            updater_platform: windows-x86_64
            stable_label: win64
          - platform: macos-latest
            target: x86_64-apple-darwin
            bundles: "app"
            updater_platform: darwin-x86_64
            stable_label: macos-intel
          - platform: macos-latest
            target: aarch64-apple-darwin
            bundles: "app"
            updater_platform: darwin-aarch64
            stable_label: macos-arm

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install Rust 1.90.0
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.90.0
          components: rustfmt, clippy
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Prepare updater signing key (validate password)
        shell: bash
        run: |
          set -euo pipefail

          raw_key="${TAURI_SIGNING_PRIVATE_KEY_SECRET:-}"
          raw_pwd="${TAURI_SIGNING_PRIVATE_KEY_PASSWORD_SECRET:-}"

          if [[ -z "${raw_key//[[:space:]]/}" ]]; then
            echo "Missing required secret: TAURI_SIGNING_PRIVATE_KEY" >&2
            exit 1
          fi
          if [[ -z "$raw_pwd" ]]; then
            echo "Missing required secret: TAURI_SIGNING_PRIVATE_KEY_PASSWORD" >&2
            exit 1
          fi

          # Tauri v2 updater key is stored as a single-line base64 string (as generated by `tauri signer generate --ci`).
          # Normalize by stripping whitespace to avoid accidental newline issues in GitHub Secrets.
          key_b64="$(printf '%s' "$raw_key" | tr -d '\r\n\t ')"
          printf '%s' "$key_b64" > tauri-updater.key
          chmod 600 tauri-updater.key

          echo "::add-mask::$raw_pwd"
          echo "sign-test" > sign-test.txt

          if ! pnpm tauri signer sign -f tauri-updater.key -p "$raw_pwd" sign-test.txt >/dev/null 2>sign-check.err; then
            cat sign-check.err
            echo "Signing key/password check failed." >&2
            exit 1
          fi

          rm -f sign-test.txt.sig sign-check.err

          echo "TAURI_SIGNING_PRIVATE_KEY=$key_b64" >> "$GITHUB_ENV"
          echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD=$raw_pwd" >> "$GITHUB_ENV"
        env:
          TAURI_SIGNING_PRIVATE_KEY_SECRET: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD_SECRET: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - id: tauri
        name: Build & upload (Tauri)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          releaseId: ${{ needs.release-please.outputs.release_id }}
          tagName: ${{ needs.release-please.outputs.tag_name }}
          args: --target ${{ matrix.target }} --bundles ${{ matrix.bundles }}
      - name: Prepare stable updater assets (+ macOS zip)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p stable-assets

          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const outDir = 'stable-assets';
          const raw = process.env.ARTIFACT_PATHS || '[]';
          const updaterPlatform = String(process.env.UPDATER_PLATFORM || '').trim();
          const stableLabel = String(process.env.STABLE_LABEL || '').trim();

          let artifactPaths;
          try {
            artifactPaths = JSON.parse(raw);
          } catch (err) {
            console.error('Failed to parse ARTIFACT_PATHS as JSON.');
            console.error(raw);
            process.exit(1);
          }

          if (!Array.isArray(artifactPaths) || artifactPaths.length === 0) {
            console.error('No artifacts found (artifactPaths output is empty).');
            process.exit(1);
          }
          if (!updaterPlatform) {
            console.error('UPDATER_PLATFORM is empty.');
            process.exit(1);
          }
          if (!stableLabel) {
            console.error('STABLE_LABEL is empty.');
            process.exit(1);
          }

          function pick(predicate, label) {
            const picked = artifactPaths.find((p) => typeof p === 'string' && predicate(p));
            if (!picked) {
              console.error(`Missing required artifact: ${label}`);
              console.error('Available artifacts:');
              for (const p of artifactPaths) console.error(`- ${p}`);
              process.exit(1);
            }
            return picked;
          }

          function copy(src, name) {
            const dest = path.join(outDir, name);
            fs.copyFileSync(src, dest);
            console.log(`Copied: ${src} -> ${dest}`);
          }

          if (updaterPlatform.startsWith('windows-')) {
            const msi = pick(
              (p) => p.toLowerCase().endsWith('.msi') && !p.toLowerCase().endsWith('.msi.sig'),
              '*.msi',
            );
            const msiSig = pick((p) => p.toLowerCase().endsWith('.msi.sig'), '*.msi.sig');
            copy(msi, `aio-coding-hub-${stableLabel}.msi`);
            copy(msiSig, `aio-coding-hub-${stableLabel}.msi.sig`);
            process.exit(0);
          }

          if (!updaterPlatform.startsWith('darwin-')) {
            console.error(`Unsupported UPDATER_PLATFORM: ${updaterPlatform}`);
            process.exit(1);
          }

          const tgz =
            artifactPaths.find((p) => typeof p === 'string' && p.toLowerCase().endsWith('.app.tar.gz')) ||
            artifactPaths.find((p) => typeof p === 'string' && p.toLowerCase().endsWith('.tar.gz'));
          if (!tgz) {
            console.error('Missing required artifact: macOS updater tarball (*.app.tar.gz / *.tar.gz)');
            console.error('Available artifacts:');
            for (const p of artifactPaths) console.error(`- ${p}`);
            process.exit(1);
          }

          const tgzSig =
            artifactPaths.find((p) => typeof p === 'string' && p.toLowerCase().endsWith('.app.tar.gz.sig')) ||
            artifactPaths.find((p) => typeof p === 'string' && p.toLowerCase().endsWith('.tar.gz.sig'));
          if (!tgzSig) {
            console.error('Missing required artifact: macOS updater signature (*.tar.gz.sig)');
            console.error('Available artifacts:');
            for (const p of artifactPaths) console.error(`- ${p}`);
            process.exit(1);
          }

          copy(tgz, `aio-coding-hub-${stableLabel}.tar.gz`);
          copy(tgzSig, `aio-coding-hub-${stableLabel}.tar.gz.sig`);
          NODE
        env:
          ARTIFACT_PATHS: ${{ steps.tauri.outputs.artifactPaths }}
          UPDATER_PLATFORM: ${{ matrix.updater_platform }}
          STABLE_LABEL: ${{ matrix.stable_label }}

      - name: Build macOS zip (portable)
        if: startsWith(matrix.updater_platform, 'darwin-')
        shell: bash
        run: |
          set -euo pipefail

          label="${{ matrix.stable_label }}"
          tgz="stable-assets/aio-coding-hub-${label}.tar.gz"
          if [[ ! -f "$tgz" ]]; then
            echo "Missing tarball: $tgz"
            ls -la stable-assets || true
            exit 1
          fi

          tmp="$(mktemp -d)"
          tar -xzf "$tgz" -C "$tmp"
          app_path="$(find "$tmp" -maxdepth 2 -name "*.app" -type d | head -n 1 || true)"
          if [[ -z "$app_path" ]]; then
            echo "No .app found inside $tgz"
            find "$tmp" -maxdepth 3 -print || true
            exit 1
          fi

          out="stable-assets/aio-coding-hub-${label}.zip"
          ditto -c -k --sequesterRsrc --keepParent "$app_path" "$out"
          echo "Created zip: $out"

      - name: Upload stable assets (workflow artifact)
        uses: actions/upload-artifact@v4
        with:
          name: stable-assets-${{ matrix.updater_platform }}
          path: stable-assets/*
          if-no-files-found: error

      - name: Upload stable assets (GitHub Release)
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.release-please.outputs.tag_name }}
          files: stable-assets/*
          fail_on_unmatched_files: true

  assemble-latest-json:
    needs: [release-please, build]
    if: needs.release-please.outputs.release_created == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download stable assets (workflow artifacts)
        uses: actions/download-artifact@v4
        with:
          pattern: stable-assets-*
          merge-multiple: true
          path: stable-assets

      - name: Generate latest.json
        shell: bash
        run: |
          set -euo pipefail

          tag="${{ needs.release-please.outputs.tag_name }}"
          repo="${{ github.repository }}"

          version="$tag"
          repo_name="${repo#*/}"
          if [[ "$version" == "${repo_name}-v"* ]]; then
            version="${version#${repo_name}-v}"
          elif [[ "$version" == v* ]]; then
            version="${version#v}"
          fi

          pub_date="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          notes="See release: https://github.com/${repo}/releases/tag/${tag}"

          win_asset="aio-coding-hub-win64.msi"
          win_sig_file="stable-assets/aio-coding-hub-win64.msi.sig"
          mac_intel_asset="aio-coding-hub-macos-intel.tar.gz"
          mac_intel_sig_file="stable-assets/aio-coding-hub-macos-intel.tar.gz.sig"
          mac_arm_asset="aio-coding-hub-macos-arm.tar.gz"
          mac_arm_sig_file="stable-assets/aio-coding-hub-macos-arm.tar.gz.sig"

          for f in "$win_sig_file" "$mac_intel_sig_file" "$mac_arm_sig_file"; do
            if [[ ! -f "$f" ]]; then
              echo "Missing signature file: $f"
              ls -la stable-assets || true
              exit 1
            fi
          done

          win_sig="$(tr -d '\n' < "$win_sig_file")"
          mac_intel_sig="$(tr -d '\n' < "$mac_intel_sig_file")"
          mac_arm_sig="$(tr -d '\n' < "$mac_arm_sig_file")"

          win_url="https://github.com/${repo}/releases/download/${tag}/${win_asset}"
          mac_intel_url="https://github.com/${repo}/releases/download/${tag}/${mac_intel_asset}"
          mac_arm_url="https://github.com/${repo}/releases/download/${tag}/${mac_arm_asset}"

          cat > latest.json <<EOF
          {
            "version": "${version}",
            "notes": "${notes}",
            "pub_date": "${pub_date}",
            "platforms": {
              "windows-x86_64": {
                "signature": "${win_sig}",
                "url": "${win_url}"
              },
              "darwin-x86_64": {
                "signature": "${mac_intel_sig}",
                "url": "${mac_intel_url}"
              },
              "darwin-aarch64": {
                "signature": "${mac_arm_sig}",
                "url": "${mac_arm_url}"
              }
            }
          }
          EOF

          node -e "JSON.parse(require('fs').readFileSync('latest.json','utf8')); console.log('latest.json OK');"

      - name: Delete existing latest.json (best-effort)
        uses: actions/github-script@v7
        with:
          script: |
            const releaseId = Number('${{ needs.release-please.outputs.release_id }}');
            if (!Number.isFinite(releaseId) || releaseId <= 0) {
              core.setFailed(`Invalid release_id: ${releaseId}`);
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const assets = await github.paginate(github.rest.repos.listReleaseAssets, {
              owner,
              repo,
              release_id: releaseId,
              per_page: 100,
            });

            const existing = assets.find((a) => a && a.name === 'latest.json');
            if (!existing) {
              core.info('No existing latest.json asset found.');
              return;
            }

            core.info(`Deleting existing latest.json asset id=${existing.id}`);
            await github.rest.repos.deleteReleaseAsset({
              owner,
              repo,
              asset_id: existing.id,
            });

      - name: Upload latest.json (GitHub Release)
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.release-please.outputs.tag_name }}
          files: latest.json
          fail_on_unmatched_files: true

  publish:
    needs: [release-please, build, assemble-latest-json]
    if: needs.release-please.outputs.release_created == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Publish GitHub Release (unset draft)
        uses: actions/github-script@v7
        with:
          script: |
            const releaseId = Number('${{ needs.release-please.outputs.release_id }}');
            if (!Number.isFinite(releaseId) || releaseId <= 0) {
              core.setFailed(`Invalid release_id: ${releaseId}`);
              return;
            }

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false,
            });
